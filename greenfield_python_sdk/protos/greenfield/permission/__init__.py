# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: greenfield/permission/common.proto, greenfield/permission/events.proto, greenfield/permission/genesis.proto, greenfield/permission/params.proto, greenfield/permission/query.proto, greenfield/permission/tx.proto, greenfield/permission/types.proto
# plugin: python-betterproto
# This file has been @generated
from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING, Dict, List, Optional

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import common as _common__
from .. import resource as _resource__

if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class ActionType(betterproto.Enum):
    """
    ActionType defines the operations you can execute in greenfield storage network
    """

    ACTION_UNSPECIFIED = 0
    ACTION_UPDATE_BUCKET_INFO = 1
    ACTION_DELETE_BUCKET = 2
    ACTION_CREATE_OBJECT = 3
    ACTION_DELETE_OBJECT = 4
    ACTION_COPY_OBJECT = 5
    ACTION_GET_OBJECT = 6
    ACTION_EXECUTE_OBJECT = 7
    ACTION_LIST_OBJECT = 8
    ACTION_UPDATE_GROUP_MEMBER = 9
    ACTION_DELETE_GROUP = 10
    ACTION_UPDATE_OBJECT_INFO = 11
    ACTION_UPDATE_GROUP_EXTRA = 12
    ACTION_TYPE_ALL = 99


class Effect(betterproto.Enum):
    """Effect define the effect of the operation permission, include Allow or deny"""

    EFFECT_UNSPECIFIED = 0
    EFFECT_ALLOW = 1
    EFFECT_DENY = 2


class PrincipalType(betterproto.Enum):
    """
    PrincipalType refers to the identity type of system users or entities.
    In Greenfield, it usually refers to accounts or groups.
    """

    PRINCIPAL_TYPE_UNSPECIFIED = 0
    PRINCIPAL_TYPE_GNFD_ACCOUNT = 1
    PRINCIPAL_TYPE_GNFD_GROUP = 2


@dataclass(eq=False, repr=False)
class Statement(betterproto.Message):
    effect: "Effect" = betterproto.enum_field(1)
    """effect define the impact of permissions, which can be Allow/Deny"""

    actions: List["ActionType"] = betterproto.enum_field(2)
    """
    action_type define the operation type you can act. greenfield defines a set of
    permission
    that you can specify in a permissionInfo. see ActionType enum for detail.
    """

    resources: List[str] = betterproto.string_field(3)
    """
    CAN ONLY USED IN bucket level. Support fuzzy match and limit to 5.
    The sub-resource name must comply with the standard specified in the
    greenfield/types/grn.go file for Greenfield resource names.
    If the sub-resources include 'grn:o:{bucket_name}/*' in the statement, it indicates
    that specific permissions is granted to all objects within the specified bucket.
    If the sub-resources include 'grn:o:{bucket_name}/test_*' in the statement, it
    indicates that specific permissions is granted to all objects with the `test_`
    prefix within the specified bucket.
    If the sub-resources is empty, when you need to operate(excluding CreateObject) a
    specified subresource, it will be denied because it cannot match any subresource.
    """

    expiration_time: datetime = betterproto.message_field(4)
    """
    expiration_time defines how long the permission is valid. If not explicitly
    specified, it means it will not expire.
    """

    limit_size: "_common__.UInt64Value" = betterproto.message_field(5)
    """
    limit_size defines the total data size that is allowed to operate. If not explicitly
    specified, it means it will not limit.
    """


@dataclass(eq=False, repr=False)
class Principal(betterproto.Message):
    """
    Principal define the roles that can grant permissions. Currently, it can be account
    or group.
    """

    type: "PrincipalType" = betterproto.enum_field(1)
    value: str = betterproto.string_field(2)
    """
    When the type is an account, its value is sdk.AccAddress().String();
    when the type is a group, its value is math.Uint().String()
    """


@dataclass(eq=False, repr=False)
class Policy(betterproto.Message):
    id: str = betterproto.string_field(1)
    """id is an unique u256 sequence for each policy. It also be used as NFT tokenID"""

    principal: "Principal" = betterproto.message_field(2)
    """principal defines the accounts/group which the permission grants to"""

    resource_type: "_resource__.ResourceType" = betterproto.enum_field(3)
    """resource_type defines the type of resource that grants permission for"""

    resource_id: str = betterproto.string_field(4)
    """
    resource_id defines the bucket/object/group id of the resource that grants
    permission for
    """

    statements: List["Statement"] = betterproto.message_field(5)
    """
    statements defines the details content of the permission, including
    effect/actions/sub-resources
    """

    expiration_time: datetime = betterproto.message_field(6)
    """
    expiration_time defines the whole expiration time of all the statements.
    Notices: Its priority is higher than the expiration time inside the Statement
    """


@dataclass(eq=False, repr=False)
class PolicyGroup(betterproto.Message):
    """
    PolicyGroup refers to a group of policies which grant permission to Group, which is
    limited to MaxGroupNum (default 10).
    This means that a single resource can only grant permission to 10 groups. The reason
    for
    this is to enable on-chain determination of whether an operator has permission
    within a limited time.
    """

    items: List["PolicyGroupItem"] = betterproto.message_field(1)
    """
    items define a pair of policy_id and group_id. Each resource can only grant its own
    permissions to a limited number of groups
    """


@dataclass(eq=False, repr=False)
class PolicyGroupItem(betterproto.Message):
    policy_id: str = betterproto.string_field(1)
    group_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class GroupMember(betterproto.Message):
    id: str = betterproto.string_field(1)
    """
    id is an unique u256 sequence for each group member. It also be used as NFT tokenID
    """

    group_id: str = betterproto.string_field(2)
    """group_id is the unique id of the group"""

    member: str = betterproto.string_field(3)
    """member is the account address of the member"""

    expiration_time: datetime = betterproto.message_field(4)
    """expiration_time defines the expiration time of the group member"""


@dataclass(eq=False, repr=False)
class EventPutPolicy(betterproto.Message):
    policy_id: str = betterproto.string_field(1)
    """
    policy_id is an unique u256 sequence for each policy. It also be used as NFT tokenID
    """

    principal: "Principal" = betterproto.message_field(2)
    """principal defines the accounts/group which the permission grants to"""

    resource_type: "_resource__.ResourceType" = betterproto.enum_field(3)
    """resource_type defines the type of resource that grants permission for"""

    resource_id: str = betterproto.string_field(4)
    """
    resource_id defines the bucket/object/group id of the resource that grants
    permission for
    """

    statements: List["Statement"] = betterproto.message_field(5)
    """
    statements defines the details content of the permission, include
    effect/actions/sub-resources
    """

    expiration_time: datetime = betterproto.message_field(6)
    """
    expiration_time defines the whole expiration time of all the statements.
    Notices: Its priority is higher than the expiration time inside the Statement
    """


@dataclass(eq=False, repr=False)
class EventDeletePolicy(betterproto.Message):
    policy_id: str = betterproto.string_field(1)
    """
    policy_id is an unique u256 sequence for each policy. It also be used as NFT tokenID
    """


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    maximum_statements_num: int = betterproto.uint64_field(1)
    """
    maximum_statements_num defines the maximum number of statements allowed in a policy
    """

    maximum_group_num: int = betterproto.uint64_field(2)
    """
    maximum_group_num used to set the upper limit on the number of groups to which a
    resource can grant access permissions.
    By placing a cap on the number of group permissions, permission control policies can
    be made more robust and better
    enforced, thereby reducing the chances of DDos and other security incidents.
    """

    maximum_remove_expired_policies_iteration: int = betterproto.uint64_field(3)
    """the maximum iteration number of `RemoveExpiredPolicies` loops in endblocker"""


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the permission module's genesis state."""

    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """QueryParamsResponse is response type for the Query/Params RPC method."""

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the Msg/UpdateParams request type."""

    authority: str = betterproto.string_field(1)
    """
    authority is the address that controls the module (defaults to x/gov unless
    overwritten).
    """

    params: "Params" = betterproto.message_field(2)
    """
    params defines the x/permission parameters to update.
    NOTE: All parameters must be supplied.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse defines the response structure for executing a
    MsgUpdateParams message.
    """

    pass


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/greenfield.permission.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/greenfield.permission.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def params(self, query_params_request: "QueryParamsRequest") -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/greenfield.permission.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def update_params(self, msg_update_params: "MsgUpdateParams") -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/greenfield.permission.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
        }
