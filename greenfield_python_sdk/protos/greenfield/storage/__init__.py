# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: greenfield/storage/common.proto, greenfield/storage/events.proto, greenfield/storage/genesis.proto, greenfield/storage/params.proto, greenfield/storage/query.proto, greenfield/storage/tx.proto, greenfield/storage/types.proto
# plugin: python-betterproto
# This file has been @generated

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from dataclasses import dataclass
else:
    from pydantic.dataclasses import dataclass

from datetime import datetime
from typing import TYPE_CHECKING, Dict, List, Optional

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...cosmos.base.query import v1beta1 as __cosmos_base_query_v1_beta1__
from .. import common as _common__
from .. import permission as _permission__
from .. import virtualgroup as _virtualgroup__

if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class SourceType(betterproto.Enum):
    """
    SourceType represents the source of resource creation, which can from
    Greenfield native or from a cross-chain transfer from BSC
    """

    SOURCE_TYPE_ORIGIN = 0
    SOURCE_TYPE_MIRROR_PENDING = 1
    SOURCE_TYPE_BSC_CROSS_CHAIN = 2
    SOURCE_TYPE_OP_CROSS_CHAIN = 3


class BucketStatus(betterproto.Enum):
    """
    BucketStatus represents the status of a bucket. After a user successfully
    sends a CreateBucket transaction onto the chain, the status is set to
    'Created'. When a Discontinue Object transaction is received on chain, the
    status is set to 'Discontinued'.
    """

    BUCKET_STATUS_CREATED = 0
    BUCKET_STATUS_DISCONTINUED = 1
    BUCKET_STATUS_MIGRATING = 2


class RedundancyType(betterproto.Enum):
    """
    RedundancyType represents the redundancy algorithm type for object data,
    which can be either multi-replica or erasure coding.
    """

    REDUNDANCY_EC_TYPE = 0
    REDUNDANCY_REPLICA_TYPE = 1


class ObjectStatus(betterproto.Enum):
    """
    ObjectStatus represents the creation status of an object. After a user
    successfully sends a CreateObject transaction onto the chain, the status is
    set to 'Created'. After the Primary Service Provider successfully sends a
    Seal Object transaction onto the chain, the status is set to 'Sealed'. When
    a Discontinue Object transaction is received on chain, the status is set to
    'Discontinued'.
    """

    OBJECT_STATUS_CREATED = 0
    OBJECT_STATUS_SEALED = 1
    OBJECT_STATUS_DISCONTINUED = 2


class VisibilityType(betterproto.Enum):
    """VisibilityType is the resources public status."""

    VISIBILITY_TYPE_UNSPECIFIED = 0
    VISIBILITY_TYPE_PUBLIC_READ = 1
    VISIBILITY_TYPE_PRIVATE = 2
    VISIBILITY_TYPE_INHERIT = 3
    """
    If the bucket Visibility is inherit, it's finally set to private. If the
    object Visibility is inherit, it's the same as bucket.
    """


@dataclass(eq=False, repr=False)
class SecondarySpSealObjectSignDoc(betterproto.Message):
    """
    SecondarySpSealObjectSignDoc used to generate seal signature of secondary
    SP If the secondary SP only signs the checksum to declare the object pieces
    are saved, it might be reused by the primary SP to fake it's declaration.
    Then the primary SP can challenge and slash the secondary SP. So the id of
    the object is needed to prevent this.
    """

    chain_id: str = betterproto.string_field(1)
    global_virtual_group_id: int = betterproto.uint32_field(2)
    object_id: str = betterproto.string_field(3)
    checksum: bytes = betterproto.bytes_field(4)
    """
    checksum is the sha256 hash of slice of integrity hash from secondary sps
    """


@dataclass(eq=False, repr=False)
class GvgMapping(betterproto.Message):
    src_global_virtual_group_id: int = betterproto.uint32_field(1)
    dst_global_virtual_group_id: int = betterproto.uint32_field(2)
    secondary_sp_bls_signature: bytes = betterproto.bytes_field(3)


@dataclass(eq=False, repr=False)
class SecondarySpMigrationBucketSignDoc(betterproto.Message):
    chain_id: str = betterproto.string_field(1)
    dst_primary_sp_id: int = betterproto.uint32_field(2)
    src_global_virtual_group_id: int = betterproto.uint32_field(3)
    dst_global_virtual_group_id: int = betterproto.uint32_field(4)
    bucket_id: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class LocalVirtualGroup(betterproto.Message):
    """
    Local virtual group(LVG) uniquely associated with a global virtual group.
    Each bucket maintains a mapping from local virtual group to global virtual
    group Each local virtual group is associated with a unique virtual payment
    account, where all object fees are streamed to.
    """

    id: int = betterproto.uint32_field(1)
    """id is the identifier of the local virtual group."""

    global_virtual_group_id: int = betterproto.uint32_field(2)
    """
    global_virtual_group_id is the identifier of the global virtual group.
    """

    stored_size: int = betterproto.uint64_field(3)
    """
    stored_size is the size of the stored data in the local virtual group.
    """

    total_charge_size: int = betterproto.uint64_field(4)
    """
    total_charge_size is the total charged size of the objects in the LVG.
    Notice that the minimum unit of charge is 128K
    """


@dataclass(eq=False, repr=False)
class BucketInfo(betterproto.Message):
    owner: str = betterproto.string_field(1)
    """
    owner is the account address of bucket creator, it is also the bucket
    owner.
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name is a globally unique name of bucket"""

    visibility: "VisibilityType" = betterproto.enum_field(3)
    """
    visibility defines the highest permissions for bucket. When a bucket is
    public, everyone can get storage objects in it.
    """

    id: str = betterproto.string_field(4)
    """id is the unique identification for bucket."""

    source_type: "SourceType" = betterproto.enum_field(5)
    """
    source_type defines which chain the user should send the bucket management
    transactions to
    """

    create_at: int = betterproto.int64_field(6)
    """create_at define the block timestamp when the bucket created."""

    payment_address: str = betterproto.string_field(7)
    """payment_address is the address of the payment account"""

    global_virtual_group_family_id: int = betterproto.uint32_field(8)
    """global_virtual_group_family_id defines the unique id of gvg family"""

    charged_read_quota: int = betterproto.uint64_field(9)
    """
    charged_read_quota defines the traffic quota for read in bytes per month.
    The available read data for each user is the sum of the free read data
    provided by SP and the ChargeReadQuota specified here.
    """

    bucket_status: "BucketStatus" = betterproto.enum_field(10)
    """bucket_status define the status of the bucket."""


@dataclass(eq=False, repr=False)
class InternalBucketInfo(betterproto.Message):
    price_time: int = betterproto.int64_field(1)
    """
    the time of the payment price, used to calculate the charge rate of the
    bucket
    """

    total_charge_size: int = betterproto.uint64_field(2)
    """
    the total size of the objects in the bucket, used to calculate the charge
    rate of the bucket
    """

    local_virtual_groups: List["LocalVirtualGroup"] = betterproto.message_field(3)
    """local_virtual_groups contains all the lvg of this bucket."""

    next_local_virtual_group_id: int = betterproto.uint32_field(4)
    """
    next_local_virtual_group_id store the next id used by local virtual group
    """


@dataclass(eq=False, repr=False)
class ObjectInfo(betterproto.Message):
    owner: str = betterproto.string_field(1)
    """owner is the object owner"""

    creator: str = betterproto.string_field(2)
    """
    creator is the address of the uploader, it always be same as owner address
    """

    bucket_name: str = betterproto.string_field(3)
    """bucket_name is the name of the bucket"""

    object_name: str = betterproto.string_field(4)
    """object_name is the name of object"""

    id: str = betterproto.string_field(5)
    """id is the unique identifier of object"""

    local_virtual_group_id: int = betterproto.uint32_field(6)
    payload_size: int = betterproto.uint64_field(7)
    """payloadSize is the total size of the object payload"""

    visibility: "VisibilityType" = betterproto.enum_field(8)
    """
    visibility defines the highest permissions for object. When an object is
    public, everyone can access it.
    """

    content_type: str = betterproto.string_field(9)
    """
    content_type define the format of the object which should be a standard
    MIME type.
    """

    create_at: int = betterproto.int64_field(10)
    """create_at define the block timestamp when the object is created"""

    object_status: "ObjectStatus" = betterproto.enum_field(11)
    """object_status define the upload status of the object."""

    redundancy_type: "RedundancyType" = betterproto.enum_field(12)
    """
    redundancy_type define the type of the redundancy which can be multi-
    replication or EC.
    """

    source_type: "SourceType" = betterproto.enum_field(13)
    """source_type define the source of the object."""

    checksums: List[bytes] = betterproto.bytes_field(14)
    """
    checksums define the root hash of the pieces which stored in a SP. add omit
    tag to omit the field when converting to NFT metadata
    """


@dataclass(eq=False, repr=False)
class GroupInfo(betterproto.Message):
    owner: str = betterproto.string_field(1)
    """owner is the owner of the group. It can not changed once it created."""

    group_name: str = betterproto.string_field(2)
    """group_name is the name of group which is unique under an account."""

    source_type: "SourceType" = betterproto.enum_field(3)
    """source_type"""

    id: str = betterproto.string_field(4)
    """id is the unique identifier of group"""

    extra: str = betterproto.string_field(5)
    """extra is used to store extra info for the group"""


@dataclass(eq=False, repr=False)
class Trait(betterproto.Message):
    trait_type: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class BucketMetaData(betterproto.Message):
    description: str = betterproto.string_field(1)
    """description"""

    external_url: str = betterproto.string_field(2)
    """externalUrl a link to external site to view NFT"""

    bucket_name: str = betterproto.string_field(3)
    """name of bucket NFT"""

    image: str = betterproto.string_field(4)
    """image is the link to image"""

    attributes: List["Trait"] = betterproto.message_field(5)
    """attributes"""


@dataclass(eq=False, repr=False)
class ObjectMetaData(betterproto.Message):
    description: str = betterproto.string_field(1)
    """description"""

    external_url: str = betterproto.string_field(2)
    """externalUrl a link to external site to view NFT"""

    object_name: str = betterproto.string_field(3)
    """name of object NFT"""

    image: str = betterproto.string_field(4)
    """image is the link to image"""

    attributes: List["Trait"] = betterproto.message_field(5)
    """attributes"""


@dataclass(eq=False, repr=False)
class GroupMetaData(betterproto.Message):
    description: str = betterproto.string_field(1)
    """description"""

    external_url: str = betterproto.string_field(2)
    """externalUrl a link to external site to view NFT"""

    group_name: str = betterproto.string_field(3)
    """name of group NFT"""

    image: str = betterproto.string_field(4)
    """image is the link to image"""

    attributes: List["Trait"] = betterproto.message_field(5)
    """attributes"""


@dataclass(eq=False, repr=False)
class Ids(betterproto.Message):
    id: List[str] = betterproto.string_field(1)
    """ids of the objects or buckets"""


@dataclass(eq=False, repr=False)
class DeleteInfo(betterproto.Message):
    bucket_ids: "Ids" = betterproto.message_field(1)
    object_ids: "Ids" = betterproto.message_field(2)
    group_ids: "Ids" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class MigrationBucketInfo(betterproto.Message):
    src_sp_id: int = betterproto.uint32_field(1)
    src_global_virtual_group_family_id: int = betterproto.uint32_field(2)
    dst_sp_id: int = betterproto.uint32_field(3)
    bucket_id: str = betterproto.string_field(4)
    """id is the unique identifier of bucket"""


@dataclass(eq=False, repr=False)
class EventCreateBucket(betterproto.Message):
    """EventCreateBucket is emitted on MsgCreateBucket"""

    owner: str = betterproto.string_field(1)
    """owner define the account address of bucket owner"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name is a globally unique name of bucket"""

    visibility: "VisibilityType" = betterproto.enum_field(3)
    """
    visibility defines the highest permissions for bucket. When a bucket is
    public, everyone can get the object under it.
    """

    create_at: int = betterproto.int64_field(4)
    """
    create_at define the block timestamp when the bucket has been created
    """

    bucket_id: str = betterproto.string_field(5)
    """
    bucket_id is the unique u256 for bucket. Not global, only unique in
    buckets.
    """

    source_type: "SourceType" = betterproto.enum_field(6)
    """
    source_type define the source of the bucket. CrossChain or Greenfield
    origin
    """

    charged_read_quota: int = betterproto.uint64_field(7)
    """
    read_quota defines the charged traffic quota for read, not include free
    quota which provided by each storage provider
    """

    payment_address: str = betterproto.string_field(8)
    """payment_address is the address of the payment account"""

    primary_sp_id: int = betterproto.uint32_field(9)
    """primary_sp_id is the unique id of primary sp."""

    global_virtual_group_family_id: int = betterproto.uint32_field(10)
    """global_virtual_group_family_id defines the unique id of gvg family"""

    status: "BucketStatus" = betterproto.enum_field(11)
    """status define the status of the bucket."""


@dataclass(eq=False, repr=False)
class EventDeleteBucket(betterproto.Message):
    """EventDeleteBucket is emitted on MsgDeleteBucket"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who delete the bucket
    """

    owner: str = betterproto.string_field(2)
    """owner define the account address of the bucket owner"""

    bucket_name: str = betterproto.string_field(3)
    """bucket_name define the name of the deleted bucket"""

    bucket_id: str = betterproto.string_field(4)
    """bucket_id define an u256 id for bucket"""

    global_virtual_group_family_id: int = betterproto.uint32_field(5)
    """global_virtual_group_family_id defines the unique id of gvg family"""


@dataclass(eq=False, repr=False)
class EventUpdateBucketInfo(betterproto.Message):
    """EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who update the bucket
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    bucket_id: str = betterproto.string_field(3)
    """bucket_id define an u256 id for bucket"""

    charged_read_quota: int = betterproto.uint64_field(4)
    """charged_read_quota_after define the read quota after updated"""

    payment_address: str = betterproto.string_field(5)
    """payment_address define the payment address after updated"""

    visibility: "VisibilityType" = betterproto.enum_field(6)
    """visibility defines the highest permission of object."""

    global_virtual_group_family_id: int = betterproto.uint32_field(7)
    """
    global_virtual_group_family_id defines the gvg family id after migrated.
    """


@dataclass(eq=False, repr=False)
class EventDiscontinueBucket(betterproto.Message):
    """EventDiscontinueBucket is emitted on MsgDiscontinueBucket"""

    bucket_id: str = betterproto.string_field(1)
    """bucket_id define id of the bucket"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    reason: str = betterproto.string_field(3)
    """the reason"""

    delete_at: int = betterproto.int64_field(4)
    """the timestamp after which the metadata will be deleted"""


@dataclass(eq=False, repr=False)
class EventCreateObject(betterproto.Message):
    """EventCreateObject is emitted on MsgCreateObject"""

    creator: str = betterproto.string_field(1)
    """creator define the account address of msg creator"""

    owner: str = betterproto.string_field(2)
    """owner define the account address of object owner"""

    bucket_name: str = betterproto.string_field(3)
    """bucket_name define the name of bucket"""

    object_name: str = betterproto.string_field(4)
    """object_name define the name of object"""

    bucket_id: str = betterproto.string_field(6)
    """bucket_id define an u256 id for object"""

    object_id: str = betterproto.string_field(7)
    """object_id define an u256 id for object"""

    primary_sp_id: int = betterproto.uint32_field(8)
    """primary_sp_id define the unique id of primary sp"""

    payload_size: int = betterproto.uint64_field(9)
    """payload_size define the size of payload data which you want upload"""

    visibility: "VisibilityType" = betterproto.enum_field(10)
    """visibility defines the highest permission of object."""

    content_type: str = betterproto.string_field(11)
    """content_type define the content type of the payload data"""

    create_at: int = betterproto.int64_field(12)
    """create_at define the block timestamp when the object created"""

    status: "ObjectStatus" = betterproto.enum_field(13)
    """status define the status of the object. INIT or IN_SERVICE or others"""

    redundancy_type: "RedundancyType" = betterproto.enum_field(14)
    """redundancy_type define the type of redundancy. Replication or EC"""

    source_type: "SourceType" = betterproto.enum_field(15)
    """
    source_type define the source of the object.  CrossChain or Greenfield
    origin
    """

    checksums: List[bytes] = betterproto.bytes_field(16)
    """
    checksums define the total checksums of the object which generated by
    redundancy
    """

    local_virtual_group_id: int = betterproto.uint32_field(17)
    """
    local_virtual_group_id defines the unique id of lvg which the object stored
    """


@dataclass(eq=False, repr=False)
class EventCancelCreateObject(betterproto.Message):
    """EventCancelCreateObject is emitted on MsgCancelCreateObject"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who cancel create object
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    primary_sp_id: int = betterproto.uint32_field(4)
    """primary_sp_id define the unique id of primary sp"""

    object_id: str = betterproto.string_field(6)
    """id define an u256 id for object"""


@dataclass(eq=False, repr=False)
class EventSealObject(betterproto.Message):
    """EventSealObject is emitted on MsgSealObject"""

    operator: str = betterproto.string_field(1)
    """operator define the account address of operator who seal object"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(5)
    """id define an u256 id for object"""

    status: "ObjectStatus" = betterproto.enum_field(6)
    """status define the status of the object. INIT or IN_SERVICE or others"""

    global_virtual_group_id: int = betterproto.uint32_field(7)
    """
    global_virtual_group_id defines the unique id of gvg which the object
    stored
    """

    local_virtual_group_id: int = betterproto.uint32_field(8)
    """
    local_virtual_group_id defines the unique id of lvg which the object stored
    """


@dataclass(eq=False, repr=False)
class EventCopyObject(betterproto.Message):
    """EventCopyObject is emitted on MsgCopyObject"""

    operator: str = betterproto.string_field(1)
    """operator define the account address of operator who copy the object"""

    src_bucket_name: str = betterproto.string_field(2)
    """src_bucket_name define the name of the src bucket"""

    src_object_name: str = betterproto.string_field(3)
    """src_object_name define the name of the src object"""

    dst_bucket_name: str = betterproto.string_field(4)
    """dst_bucket_name define the name of the dst bucket"""

    dst_object_name: str = betterproto.string_field(5)
    """dst_object_name define the name of the dst object"""

    src_object_id: str = betterproto.string_field(6)
    """src_object_id define the u256 id for src object"""

    dst_object_id: str = betterproto.string_field(7)
    """dst_object_id define the u256 id for dst object"""

    local_virtual_group_id: int = betterproto.uint32_field(8)
    """
    local_virtual_group_id defines the unique id of lvg which the object stored
    """


@dataclass(eq=False, repr=False)
class EventDeleteObject(betterproto.Message):
    """EventDeleteObject is emitted on MsgDeleteObject"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who delete the object
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(4)
    """id define an u256 id for object"""

    local_virtual_group_id: int = betterproto.uint32_field(5)
    """
    local_virtual_group_id defines the unique id of lvg which the object stored
    """


@dataclass(eq=False, repr=False)
class EventRejectSealObject(betterproto.Message):
    """EventRejectSealObject is emitted on MsgRejectSealObject"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who reject seal object
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(4)
    """id define an u256 id for object"""


@dataclass(eq=False, repr=False)
class EventDiscontinueObject(betterproto.Message):
    """EventDiscontinueObject is emitted on MsgDiscontinueObject"""

    bucket_name: str = betterproto.string_field(1)
    """bucket_name define the name of the bucket"""

    object_id: str = betterproto.string_field(2)
    """object_id defines id of the object"""

    reason: str = betterproto.string_field(3)
    """the reason"""

    delete_at: int = betterproto.int64_field(4)
    """the timestamp after which the metadata will be deleted"""


@dataclass(eq=False, repr=False)
class EventUpdateObjectInfo(betterproto.Message):
    """EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who update the bucket
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(4)
    """object_id define an u256 id for object"""

    visibility: "VisibilityType" = betterproto.enum_field(5)
    """visibility defines the highest permission of object."""


@dataclass(eq=False, repr=False)
class EventCreateGroup(betterproto.Message):
    """EventCreateGroup is emitted on MsgCreateGroup"""

    owner: str = betterproto.string_field(1)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(2)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(3)
    """id define an u256 id for group"""

    source_type: "SourceType" = betterproto.enum_field(4)
    """
    source_type define the source of the group. CrossChain or Greenfield origin
    """

    extra: str = betterproto.string_field(5)
    """extra defines extra info for the group"""


@dataclass(eq=False, repr=False)
class EventDeleteGroup(betterproto.Message):
    """EventDeleteGroup is emitted on MsgDeleteGroup"""

    owner: str = betterproto.string_field(2)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(4)
    """id define an u256 id for group"""


@dataclass(eq=False, repr=False)
class EventLeaveGroup(betterproto.Message):
    """EventLeaveGroup is emitted on MsgLeaveGroup"""

    member_address: str = betterproto.string_field(1)
    """member_address define the address of the member who leave the group"""

    owner: str = betterproto.string_field(2)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(4)
    """id define an u256 id for group"""


@dataclass(eq=False, repr=False)
class EventUpdateGroupMember(betterproto.Message):
    """EventUpdateGroupMember is emitted on MsgUpdateGroupMember"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who update the group member
    """

    owner: str = betterproto.string_field(2)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(4)
    """id define an u256 id for group"""

    members_to_add: List["EventGroupMemberDetail"] = betterproto.message_field(5)
    """members_to_add defines all the members to be added to the group"""

    members_to_delete: List[str] = betterproto.string_field(6)
    """members_to_add defines all the members to be deleted from the group"""


@dataclass(eq=False, repr=False)
class EventRenewGroupMember(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who update the group member
    """

    owner: str = betterproto.string_field(2)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(4)
    """id define an u256 id for group"""

    source_type: "SourceType" = betterproto.enum_field(5)
    """
    source_type define the source of the group. CrossChain or Greenfield origin
    """

    members: List["EventGroupMemberDetail"] = betterproto.message_field(6)
    """members define the all the address of the members."""


@dataclass(eq=False, repr=False)
class EventGroupMemberDetail(betterproto.Message):
    member: str = betterproto.string_field(1)
    """member defines the account address of the group member"""

    expiration_time: datetime = betterproto.message_field(2)
    """expiration_time defines the expiration time of the group member"""


@dataclass(eq=False, repr=False)
class EventUpdateGroupExtra(betterproto.Message):
    """EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who update the group member
    """

    owner: str = betterproto.string_field(2)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(4)
    """id define an u256 id for group"""

    extra: str = betterproto.string_field(5)
    """extra defines extra info for the group to update"""


@dataclass(eq=False, repr=False)
class EventMirrorBucket(betterproto.Message):
    """EventMirrorBucket is emitted on MirrorBucket"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who mirror the bucket
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket"""

    bucket_id: str = betterproto.string_field(4)
    """bucket_id define an u256 id for bucket"""

    dest_chain_id: int = betterproto.uint32_field(5)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventMirrorBucketResult(betterproto.Message):
    """
    EventMirrorBucketResult is emitted on receiving ack package from
    destination chain
    """

    status: int = betterproto.uint32_field(1)
    """status define the status of the result"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket"""

    bucket_id: str = betterproto.string_field(4)
    """bucket_id define an u256 id for bucket"""

    dest_chain_id: int = betterproto.uint32_field(5)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventMirrorObject(betterproto.Message):
    """EventMirrorObject is emitted on MirrorObject"""

    operator: str = betterproto.string_field(1)
    """
    operator define the account address of operator who delete the object
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(4)
    """object_id define an u256 id for object"""

    dest_chain_id: int = betterproto.uint32_field(5)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventMirrorObjectResult(betterproto.Message):
    """
    EventMirrorObjectResult is emitted on receiving ack package from
    destination chain
    """

    status: int = betterproto.uint32_field(1)
    """status define the status of the result"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name define the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name define the name of the object"""

    object_id: str = betterproto.string_field(4)
    """object_id define an u256 id for object"""

    dest_chain_id: int = betterproto.uint32_field(5)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventMirrorGroup(betterproto.Message):
    """EventMirrorGroup is emitted on MirrorGroup"""

    owner: str = betterproto.string_field(1)
    """owner define the account address of group owner"""

    group_name: str = betterproto.string_field(2)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(3)
    """group_id define an u256 id for group"""

    dest_chain_id: int = betterproto.uint32_field(4)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventMirrorGroupResult(betterproto.Message):
    """
    EventMirrorGroupResult is emitted on receiving ack package from destination
    chain
    """

    status: int = betterproto.uint32_field(1)
    """status define the status of the result"""

    group_name: str = betterproto.string_field(2)
    """group_name define the name of the group"""

    group_id: str = betterproto.string_field(3)
    """group_id define an u256 id for group"""

    dest_chain_id: int = betterproto.uint32_field(4)
    """chain id of the destination chain"""


@dataclass(eq=False, repr=False)
class EventStalePolicyCleanup(betterproto.Message):
    """
    EventStalePolicyCleanup is emitted when specified block height's stale
    policies need to be Garbage collected
    """

    block_num: int = betterproto.int64_field(1)
    delete_info: "DeleteInfo" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EventMigrationBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    The address of the operator that initiated the bucket migration, usually
    the owner of the bucket or another account which has permission to operate
    """

    bucket_name: str = betterproto.string_field(2)
    """The name of the bucket to be migrated"""

    bucket_id: str = betterproto.string_field(3)
    """bucket_id define an u256 id for object"""

    dst_primary_sp_id: int = betterproto.uint32_field(4)
    """The id of the destination primary sp"""


@dataclass(eq=False, repr=False)
class EventCancelMigrationBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    The address of the operator that canceled the bucket migration, usually the
    owner of the bucket or another account which has permission to operate
    """

    bucket_name: str = betterproto.string_field(2)
    """The name of the bucket to be migrated"""

    bucket_id: str = betterproto.string_field(3)
    """bucket_id define an u256 id for object"""


@dataclass(eq=False, repr=False)
class EventCompleteMigrationBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    The address of the operator that initiated the bucket migration, usually
    the owner of the bucket or another account which has permission to operate
    """

    bucket_name: str = betterproto.string_field(2)
    """The name of the bucket to be migrated"""

    bucket_id: str = betterproto.string_field(3)
    """bucket_id define an u256 id for object"""

    global_virtual_group_family_id: int = betterproto.uint32_field(4)
    """The family id that the bucket to be migrated to"""

    src_primary_sp_id: int = betterproto.uint32_field(5)
    """
    The src_primary_sp_id defines the primary sp id of the bucket before
    migrate.
    """


@dataclass(eq=False, repr=False)
class Params(betterproto.Message):
    """Params defines the parameters for the module."""

    versioned_params: "VersionedParams" = betterproto.message_field(1)
    max_payload_size: int = betterproto.uint64_field(2)
    """max_payload_size is the maximum size of the payload, default: 2G"""

    bsc_mirror_bucket_relayer_fee: str = betterproto.string_field(3)
    """relayer fee for the mirror bucket tx to bsc"""

    bsc_mirror_bucket_ack_relayer_fee: str = betterproto.string_field(4)
    """
    relayer fee for the ACK or FAIL_ACK package of the mirror bucket tx to bsc
    """

    bsc_mirror_object_relayer_fee: str = betterproto.string_field(5)
    """relayer fee for the mirror object tx to bsc"""

    bsc_mirror_object_ack_relayer_fee: str = betterproto.string_field(6)
    """
    Relayer fee for the ACK or FAIL_ACK package of the mirror object tx to bsc
    """

    bsc_mirror_group_relayer_fee: str = betterproto.string_field(7)
    """relayer fee for the mirror object tx to bsc"""

    bsc_mirror_group_ack_relayer_fee: str = betterproto.string_field(8)
    """
    Relayer fee for the ACK or FAIL_ACK package of the mirror object tx to bsc
    """

    max_buckets_per_account: int = betterproto.uint32_field(9)
    """The maximum number of buckets that can be created per account"""

    discontinue_counting_window: int = betterproto.uint64_field(10)
    """The window to count the discontinued objects or buckets"""

    discontinue_object_max: int = betterproto.uint64_field(11)
    """The max objects can be requested in a window"""

    discontinue_bucket_max: int = betterproto.uint64_field(12)
    """The max buckets can be requested in a window"""

    discontinue_confirm_period: int = betterproto.int64_field(13)
    """The object will be deleted after the confirm period in seconds"""

    discontinue_deletion_max: int = betterproto.uint64_field(14)
    """The max delete objects in each end block"""

    stale_policy_cleanup_max: int = betterproto.uint64_field(15)
    """The max number for deleting policy in each end block"""

    min_quota_update_interval: int = betterproto.uint64_field(16)
    """The min interval for making quota smaller in seconds"""

    max_local_virtual_group_num_per_bucket: int = betterproto.uint32_field(17)
    """the max number of local virtual group per bucket"""

    op_mirror_bucket_relayer_fee: str = betterproto.string_field(18)
    """relayer fee for the mirror bucket tx to op chain"""

    op_mirror_bucket_ack_relayer_fee: str = betterproto.string_field(19)
    """
    relayer fee for the ACK or FAIL_ACK package of the mirror bucket tx to op
    chain
    """

    op_mirror_object_relayer_fee: str = betterproto.string_field(20)
    """relayer fee for the mirror object tx to op chain"""

    op_mirror_object_ack_relayer_fee: str = betterproto.string_field(21)
    """
    Relayer fee for the ACK or FAIL_ACK package of the mirror object tx to op
    chain
    """

    op_mirror_group_relayer_fee: str = betterproto.string_field(22)
    """relayer fee for the mirror object tx to op chain"""

    op_mirror_group_ack_relayer_fee: str = betterproto.string_field(23)
    """
    Relayer fee for the ACK or FAIL_ACK package of the mirror object tx to op
    chain
    """


@dataclass(eq=False, repr=False)
class VersionedParams(betterproto.Message):
    """
    VersionedParams defines the parameters for the storage module with multi
    version, each version store with different timestamp.
    """

    max_segment_size: int = betterproto.uint64_field(1)
    """max_segment_size is the maximum size of a segment. default: 16M"""

    redundant_data_chunk_num: int = betterproto.uint32_field(2)
    """
    redundant_data_check_num is the num of data chunks of EC redundancy
    algorithm
    """

    redundant_parity_chunk_num: int = betterproto.uint32_field(3)
    """
    redundant_data_check_num is the num of parity chunks of EC redundancy
    algorithm
    """

    min_charge_size: int = betterproto.uint64_field(4)
    """
    min_charge_size is the minimum charge size of the payload, objects smaller
    than this size will be charged as this size
    """


@dataclass(eq=False, repr=False)
class GenesisState(betterproto.Message):
    """GenesisState defines the bridge module's genesis state."""

    params: "Params" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryParamsRequest(betterproto.Message):
    """QueryParamsRequest is request type for the Query/Params RPC method."""

    pass


@dataclass(eq=False, repr=False)
class QueryParamsResponse(betterproto.Message):
    """
    QueryParamsResponse is response type for the Query/Params RPC method.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryParamsByTimestampRequest(betterproto.Message):
    """
    QueryVersionedParamsRequest is request type for the Query/Params RPC method
    with timestamp.
    """

    timestamp: int = betterproto.int64_field(1)
    """the timestamp of the block time you want to query"""


@dataclass(eq=False, repr=False)
class QueryParamsByTimestampResponse(betterproto.Message):
    """
    QueryVersionedParamsResponse is response type for the Query/Params RPC
    method with timestamp.
    """

    params: "Params" = betterproto.message_field(1)
    """params holds all the parameters of this module."""


@dataclass(eq=False, repr=False)
class QueryHeadBucketRequest(betterproto.Message):
    bucket_name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadBucketByIdRequest(betterproto.Message):
    bucket_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadBucketResponse(betterproto.Message):
    bucket_info: "BucketInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadObjectRequest(betterproto.Message):
    bucket_name: str = betterproto.string_field(1)
    object_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryHeadObjectByIdRequest(betterproto.Message):
    object_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadObjectResponse(betterproto.Message):
    object_info: "ObjectInfo" = betterproto.message_field(1)
    global_virtual_group: "_virtualgroup__.GlobalVirtualGroup" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryListBucketsRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryListBucketsResponse(betterproto.Message):
    bucket_infos: List["BucketInfo"] = betterproto.message_field(1)
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryListObjectsRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)
    bucket_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryListObjectsByBucketIdRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)
    bucket_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryListObjectsResponse(betterproto.Message):
    object_infos: List["ObjectInfo"] = betterproto.message_field(1)
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryNftRequest(betterproto.Message):
    token_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryBucketNftResponse(betterproto.Message):
    meta_data: "BucketMetaData" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryObjectNftResponse(betterproto.Message):
    meta_data: "ObjectMetaData" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupNftResponse(betterproto.Message):
    meta_data: "GroupMetaData" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPolicyForAccountRequest(betterproto.Message):
    resource: str = betterproto.string_field(1)
    principal_address: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryPolicyForAccountResponse(betterproto.Message):
    policy: "_permission__.Policy" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryVerifyPermissionRequest(betterproto.Message):
    operator: str = betterproto.string_field(1)
    bucket_name: str = betterproto.string_field(2)
    object_name: str = betterproto.string_field(3)
    action_type: "_permission__.ActionType" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class QueryVerifyPermissionResponse(betterproto.Message):
    effect: "_permission__.Effect" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadGroupRequest(betterproto.Message):
    group_owner: str = betterproto.string_field(1)
    group_name: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryHeadGroupResponse(betterproto.Message):
    group_info: "GroupInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryListGroupsRequest(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageRequest" = betterproto.message_field(1)
    group_owner: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryListGroupsResponse(betterproto.Message):
    pagination: "__cosmos_base_query_v1_beta1__.PageResponse" = betterproto.message_field(1)
    group_infos: List["GroupInfo"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class QueryHeadGroupMemberRequest(betterproto.Message):
    member: str = betterproto.string_field(1)
    group_owner: str = betterproto.string_field(2)
    group_name: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class QueryHeadGroupMemberResponse(betterproto.Message):
    group_member: "_permission__.GroupMember" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPolicyForGroupRequest(betterproto.Message):
    resource: str = betterproto.string_field(1)
    principal_group_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryPolicyForGroupResponse(betterproto.Message):
    policy: "_permission__.Policy" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryPolicyByIdRequest(betterproto.Message):
    policy_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryPolicyByIdResponse(betterproto.Message):
    policy: "_permission__.Policy" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryLockFeeRequest(betterproto.Message):
    primary_sp_address: str = betterproto.string_field(1)
    """primary_sp_address is the address of the primary sp."""

    create_at: int = betterproto.int64_field(2)
    """create_at define the block timestamp when the object created."""

    payload_size: int = betterproto.uint64_field(3)
    """payloadSize is the total size of the object payload"""


@dataclass(eq=False, repr=False)
class QueryLockFeeResponse(betterproto.Message):
    amount: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadBucketExtraRequest(betterproto.Message):
    bucket_name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryHeadBucketExtraResponse(betterproto.Message):
    extra_info: "InternalBucketInfo" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class QueryIsPriceChangedRequest(betterproto.Message):
    bucket_name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryIsPriceChangedResponse(betterproto.Message):
    changed: bool = betterproto.bool_field(1)
    current_read_price: str = betterproto.string_field(2)
    current_primary_store_price: str = betterproto.string_field(3)
    current_secondary_store_price: str = betterproto.string_field(4)
    current_validator_tax_rate: str = betterproto.string_field(5)
    new_read_price: str = betterproto.string_field(6)
    new_primary_store_price: str = betterproto.string_field(7)
    new_secondary_store_price: str = betterproto.string_field(8)
    new_validator_tax_rate: str = betterproto.string_field(9)


@dataclass(eq=False, repr=False)
class QueryQuoteUpdateTimeRequest(betterproto.Message):
    bucket_name: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryQuoteUpdateTimeResponse(betterproto.Message):
    update_at: int = betterproto.int64_field(6)


@dataclass(eq=False, repr=False)
class QueryGroupMembersExistRequest(betterproto.Message):
    group_id: str = betterproto.string_field(1)
    members: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupMembersExistResponse(betterproto.Message):
    exists: Dict[str, bool] = betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_BOOL)


@dataclass(eq=False, repr=False)
class QueryGroupsExistRequest(betterproto.Message):
    group_owner: str = betterproto.string_field(1)
    group_names: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class QueryGroupsExistByIdRequest(betterproto.Message):
    group_ids: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class QueryGroupsExistResponse(betterproto.Message):
    exists: Dict[str, bool] = betterproto.map_field(1, betterproto.TYPE_STRING, betterproto.TYPE_BOOL)


@dataclass(eq=False, repr=False)
class MsgCreateBucket(betterproto.Message):
    creator: str = betterproto.string_field(1)
    """
    creator defines the account address of bucket creator, it is also the
    bucket owner.
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines a globally unique name of bucket"""

    visibility: "VisibilityType" = betterproto.enum_field(3)
    """
    visibility means the bucket is private or public. if private, only bucket
    owner or grantee can read it, otherwise every greenfield user can read it.
    """

    payment_address: str = betterproto.string_field(4)
    """
    payment_address defines an account address specified by bucket owner to pay
    the read fee. Default: creator
    """

    primary_sp_address: str = betterproto.string_field(5)
    """primary_sp_address defines the address of primary sp."""

    primary_sp_approval: "_common__.Approval" = betterproto.message_field(6)
    """
    primary_sp_approval defines the approval info of the primary SP which
    indicates that primary sp confirm the user's request.
    """

    charged_read_quota: int = betterproto.uint64_field(7)
    """
    charged_read_quota defines the read data that users are charged for,
    measured in bytes. The available read data for each user is the sum of the
    free read data provided by SP and the ChargeReadQuota specified here.
    """


@dataclass(eq=False, repr=False)
class MsgCreateBucketResponse(betterproto.Message):
    bucket_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgDeleteBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    creator defines the account address of the grantee who has the DeleteBucket
    permission of the bucket to be deleted.
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket to be deleted."""


@dataclass(eq=False, repr=False)
class MsgDeleteBucketResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgDiscontinueBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator is the sp who wants to stop serving the bucket."""

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object which to be
    discontinued is stored.
    """

    reason: str = betterproto.string_field(3)
    """the reason for the request."""


@dataclass(eq=False, repr=False)
class MsgDiscontinueBucketResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCreateObject(betterproto.Message):
    creator: str = betterproto.string_field(1)
    """creator defines the account address of object uploader"""

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object is stored.
    """

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of object"""

    payload_size: int = betterproto.uint64_field(4)
    """payload_size defines size of the object's payload"""

    visibility: "VisibilityType" = betterproto.enum_field(5)
    """
    visibility means the object is private or public. if private, only object
    owner or grantee can access it, otherwise every greenfield user can access
    it.
    """

    content_type: str = betterproto.string_field(6)
    """
    content_type defines a standard MIME type describing the format of the
    object.
    """

    primary_sp_approval: "_common__.Approval" = betterproto.message_field(7)
    """
    primary_sp_approval defines the approval info of the primary SP which
    indicates that primary sp confirm the user's request.
    """

    expect_checksums: List[bytes] = betterproto.bytes_field(8)
    """
    expect_checksums defines a list of hashes which was generate by redundancy
    algorithm.
    """

    redundancy_type: "RedundancyType" = betterproto.enum_field(9)
    """redundancy_type can be ec or replica"""


@dataclass(eq=False, repr=False)
class MsgCreateObjectResponse(betterproto.Message):
    object_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgSealObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator defines the account address of primary SP"""

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object is stored.
    """

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of object to be sealed."""

    global_virtual_group_id: int = betterproto.uint32_field(4)
    """global_virtual_group_id defines the id of global virtual group"""

    secondary_sp_bls_agg_signatures: bytes = betterproto.bytes_field(5)
    """
    secondary_sp_bls_agg_signatures defines the aggregate bls signature of the
    secondary sp that can acknowledge that the payload data has received and
    stored.
    """


@dataclass(eq=False, repr=False)
class MsgSealObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgRejectSealObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator defines the account address of the object owner"""

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object is stored.
    """

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of unsealed object to be reject."""


@dataclass(eq=False, repr=False)
class MsgRejectSealObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCopyObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the CopyObject
    permission of the object to be deleted.
    """

    src_bucket_name: str = betterproto.string_field(2)
    """
    src_bucket_name defines the name of the bucket where the object to be
    copied is located
    """

    dst_bucket_name: str = betterproto.string_field(3)
    """
    dst_bucket_name defines the name of the bucket where the object is copied
    to.
    """

    src_object_name: str = betterproto.string_field(4)
    """src_object_name defines the name of the object which to be copied"""

    dst_object_name: str = betterproto.string_field(5)
    """dst_object_name defines the name of the object which is copied to"""

    dst_primary_sp_approval: "_common__.Approval" = betterproto.message_field(6)
    """
    primary_sp_approval defines the approval info of the primary SP which
    indicates that primary sp confirm the user's request.
    """


@dataclass(eq=False, repr=False)
class MsgCopyObjectResponse(betterproto.Message):
    object_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgDeleteObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    DeleteObject permission of the object to be deleted.
    """

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object which to be
    deleted is stored.
    """

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of the object which to be deleted."""


@dataclass(eq=False, repr=False)
class MsgDeleteObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgDiscontinueObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator is the sp who wants to stop serving the objects."""

    bucket_name: str = betterproto.string_field(2)
    """
    bucket_name defines the name of the bucket where the object which to be
    discontinued is stored.
    """

    object_ids: List[str] = betterproto.string_field(3)
    """object_ids are the ids of object info."""

    reason: str = betterproto.string_field(4)
    """the reason for the request."""


@dataclass(eq=False, repr=False)
class MsgDiscontinueObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCreateGroup(betterproto.Message):
    creator: str = betterproto.string_field(1)
    """
    owner defines the account address of group owner who create the group
    """

    group_name: str = betterproto.string_field(2)
    """group_name defines the name of the group. it's not globally unique."""

    extra: str = betterproto.string_field(3)
    """extra defines extra info for the group"""


@dataclass(eq=False, repr=False)
class MsgCreateGroupResponse(betterproto.Message):
    group_id: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class MsgDeleteGroup(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    DeleteGroup permission of the group to be deleted.
    """

    group_name: str = betterproto.string_field(2)
    """group_name defines the name of the group which to be deleted"""


@dataclass(eq=False, repr=False)
class MsgDeleteGroupResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMember(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    UpdateGroupMember permission of the group.
    """

    group_owner: str = betterproto.string_field(2)
    """group_owner defines the account address of the group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name defines the name of the group which to be updated"""

    members_to_add: List["MsgGroupMember"] = betterproto.message_field(4)
    """
    members_to_add defines a list of members account address which will be add
    to the group
    """

    members_to_delete: List[str] = betterproto.string_field(5)
    """
    members_to_delete defines a list of members account address which will be
    remove from the group
    """


@dataclass(eq=False, repr=False)
class MsgUpdateGroupMemberResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgRenewGroupMember(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    UpdateGroupMember permission of the group.
    """

    group_owner: str = betterproto.string_field(2)
    """group_owner defines the account address of the group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name defines the name of the group which to be updated"""

    members: List["MsgGroupMember"] = betterproto.message_field(4)
    """members defines a list of members which will be renew to the group"""


@dataclass(eq=False, repr=False)
class MsgRenewGroupMemberResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgGroupMember(betterproto.Message):
    member: str = betterproto.string_field(1)
    """member defines the account address of the group member"""

    expiration_time: datetime = betterproto.message_field(2)
    """expiration_time defines the expiration time of the group member"""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupExtra(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    UpdateGroupMember permission of the group.
    """

    group_owner: str = betterproto.string_field(2)
    """group_owner defines the account address of the group owner"""

    group_name: str = betterproto.string_field(3)
    """group_name defines the name of the group which to be updated"""

    extra: str = betterproto.string_field(4)
    """extra defines extra info for the group to update"""


@dataclass(eq=False, repr=False)
class MsgUpdateGroupExtraResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgLeaveGroup(betterproto.Message):
    member: str = betterproto.string_field(1)
    """
    member defines the account address of the member who want to leave the
    group
    """

    group_owner: str = betterproto.string_field(2)
    """group_owner defines the owner of the group you want to leave"""

    group_name: str = betterproto.string_field(3)
    """group_name defines the name of the group you want to leave"""


@dataclass(eq=False, repr=False)
class MsgLeaveGroupResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateBucketInfo(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator defines the account address of the operator"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of bucket which you'll update"""

    charged_read_quota: "_common__.UInt64Value" = betterproto.message_field(3)
    """
    charged_read_quota defines the traffic quota that you read from primary sp
    if read_quota is nil, it means don't change the read_quota
    """

    payment_address: str = betterproto.string_field(4)
    """
    payment_address defines the account address of the payment account if
    payment_address is empty, it means don't change the payment_address
    """

    visibility: "VisibilityType" = betterproto.enum_field(5)
    """
    visibility means the bucket is private or public. if private, only bucket
    owner or grantee can read it, otherwise every greenfield user can read it.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateBucketInfoResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCancelCreateObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator defines the account address of the operator"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of the object"""


@dataclass(eq=False, repr=False)
class MsgCancelCreateObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgPutPolicy(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the granter who grant the permission to another principal
    """

    principal: "_permission__.Principal" = betterproto.message_field(2)
    """
    Principal defines the roles that can grant permissions. Currently, it can
    be account or group.
    """

    resource: str = betterproto.string_field(3)
    """
    resource defines a greenfield standard resource name that can be generated
    by GRN structure
    """

    statements: List["_permission__.Statement"] = betterproto.message_field(4)
    """
    statements defines a list of individual statement which describe the detail
    rules of policy
    """

    expiration_time: datetime = betterproto.message_field(7)
    """
    expiration_time defines the whole expiration time of all the statements.
    Notices: Its priority is higher than the expiration time inside the
    Statement
    """


@dataclass(eq=False, repr=False)
class MsgPutPolicyResponse(betterproto.Message):
    policy_id: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgDeletePolicy(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the granter who grant the permission to another principal
    """

    principal: "_permission__.Principal" = betterproto.message_field(2)
    """
    Principal defines the roles that can grant permissions. Currently, it can
    be account or group.
    """

    resource: str = betterproto.string_field(3)
    """
    resource defines a greenfield standard resource name that can be generated
    by GRN structure
    """


@dataclass(eq=False, repr=False)
class MsgDeletePolicyResponse(betterproto.Message):
    policy_id: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class MsgMirrorObject(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who has the
    DeleteObject permission of the object to be deleted.
    """

    id: str = betterproto.string_field(2)
    """id defines the unique u256 for object."""

    bucket_name: str = betterproto.string_field(3)
    """
    bucket_name defines the name of the bucket where the object is stored
    """

    object_name: str = betterproto.string_field(4)
    """object_name defines the name of object"""

    dest_chain_id: int = betterproto.uint32_field(5)
    """destination chain id"""


@dataclass(eq=False, repr=False)
class MsgMirrorObjectResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgMirrorBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    creator defines the account address of the grantee who has the DeleteBucket
    permission of the bucket to be deleted.
    """

    id: str = betterproto.string_field(2)
    """id defines the unique u256 for bucket."""

    bucket_name: str = betterproto.string_field(3)
    """bucket_name defines a globally unique name of bucket"""

    dest_chain_id: int = betterproto.uint32_field(4)
    """destination chain id"""


@dataclass(eq=False, repr=False)
class MsgUpdateObjectInfoResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateObjectInfo(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """operator defines the account address of the operator"""

    bucket_name: str = betterproto.string_field(2)
    """bucket_name is the name of the bucket"""

    object_name: str = betterproto.string_field(3)
    """object_name defines the name of bucket which you'll update"""

    visibility: "VisibilityType" = betterproto.enum_field(4)
    """
    visibility means the object is private or public. if private, only bucket
    owner or grantee can read it, otherwise every greenfield user can read it.
    """


@dataclass(eq=False, repr=False)
class MsgMirrorBucketResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgMirrorGroup(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who is the owner of
    the group
    """

    id: str = betterproto.string_field(2)
    """id defines the unique u256 for group."""

    group_name: str = betterproto.string_field(3)
    """group_name defines the name of the group"""

    dest_chain_id: int = betterproto.uint32_field(4)
    """destination chain id"""


@dataclass(eq=False, repr=False)
class MsgMirrorGroupResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgUpdateParams(betterproto.Message):
    """MsgUpdateParams is the Msg/UpdateParams request type."""

    authority: str = betterproto.string_field(1)
    """
    authority is the address that controls the module (defaults to x/gov unless
    overwritten).
    """

    params: "Params" = betterproto.message_field(2)
    """
    params defines the x/storage parameters to update. NOTE: All parameters
    must be supplied.
    """


@dataclass(eq=False, repr=False)
class MsgUpdateParamsResponse(betterproto.Message):
    """
    MsgUpdateParamsResponse defines the response structure for executing a
    """

    pass


@dataclass(eq=False, repr=False)
class MsgMigrateBucket(betterproto.Message):
    """this line is used by starport scaffolding # proto/tx/message"""

    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the operator who initial the
    migrate bucket
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket that need to be migrated"""

    dst_primary_sp_id: int = betterproto.uint32_field(3)
    """dst_primary_sp_id defines the destination SP for migration"""

    dst_primary_sp_approval: "_common__.Approval" = betterproto.message_field(4)
    """dst_primary_sp_approval defines the approval of destination sp"""


@dataclass(eq=False, repr=False)
class MsgMigrateBucketResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCompleteMigrateBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the msg operator. The
    CompleteMigrateBucket transaction must be initiated by the destination SP
    of the migration
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket that need to be migrated"""

    global_virtual_group_family_id: int = betterproto.uint32_field(3)
    """
    global_virtual_group_family_id defines the family id which the bucket
    migrate to
    """

    gvg_mappings: List["GvgMapping"] = betterproto.message_field(4)
    """
    gvg_mappings defines the src and dst gvg mapping relationships which the
    bucket migrate to
    """


@dataclass(eq=False, repr=False)
class MsgCompleteMigrateBucketResponse(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MsgCancelMigrateBucket(betterproto.Message):
    operator: str = betterproto.string_field(1)
    """
    operator defines the account address of the msg operator. Only the user can
    send this transaction to cancel the migrate bucket
    """

    bucket_name: str = betterproto.string_field(2)
    """bucket_name defines the name of the bucket that need to be migrated"""


@dataclass(eq=False, repr=False)
class MsgCancelMigrateBucketResponse(betterproto.Message):
    pass


class QueryStub(betterproto.ServiceStub):
    async def params(
        self,
        query_params_request: "QueryParamsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/Params",
            query_params_request,
            QueryParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_params_by_timestamp(
        self,
        query_params_by_timestamp_request: "QueryParamsByTimestampRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryParamsByTimestampResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryParamsByTimestamp",
            query_params_by_timestamp_request,
            QueryParamsByTimestampResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_bucket(
        self,
        query_head_bucket_request: "QueryHeadBucketRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadBucket",
            query_head_bucket_request,
            QueryHeadBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_bucket_by_id(
        self,
        query_head_bucket_by_id_request: "QueryHeadBucketByIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadBucketById",
            query_head_bucket_by_id_request,
            QueryHeadBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_bucket_nft(
        self,
        query_nft_request: "QueryNftRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryBucketNftResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadBucketNFT",
            query_nft_request,
            QueryBucketNftResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_object(
        self,
        query_head_object_request: "QueryHeadObjectRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadObject",
            query_head_object_request,
            QueryHeadObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_object_by_id(
        self,
        query_head_object_by_id_request: "QueryHeadObjectByIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadObjectById",
            query_head_object_by_id_request,
            QueryHeadObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_object_nft(
        self,
        query_nft_request: "QueryNftRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryObjectNftResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadObjectNFT",
            query_nft_request,
            QueryObjectNftResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_buckets(
        self,
        query_list_buckets_request: "QueryListBucketsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryListBucketsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/ListBuckets",
            query_list_buckets_request,
            QueryListBucketsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_objects(
        self,
        query_list_objects_request: "QueryListObjectsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryListObjectsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/ListObjects",
            query_list_objects_request,
            QueryListObjectsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_objects_by_bucket_id(
        self,
        query_list_objects_by_bucket_id_request: "QueryListObjectsByBucketIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryListObjectsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/ListObjectsByBucketId",
            query_list_objects_by_bucket_id_request,
            QueryListObjectsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_group_nft(
        self,
        query_nft_request: "QueryNftRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupNftResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadGroupNFT",
            query_nft_request,
            QueryGroupNftResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_policy_for_account(
        self,
        query_policy_for_account_request: "QueryPolicyForAccountRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPolicyForAccountResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryPolicyForAccount",
            query_policy_for_account_request,
            QueryPolicyForAccountResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def verify_permission(
        self,
        query_verify_permission_request: "QueryVerifyPermissionRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryVerifyPermissionResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/VerifyPermission",
            query_verify_permission_request,
            QueryVerifyPermissionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_group(
        self,
        query_head_group_request: "QueryHeadGroupRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadGroup",
            query_head_group_request,
            QueryHeadGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_groups(
        self,
        query_list_groups_request: "QueryListGroupsRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryListGroupsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/ListGroups",
            query_list_groups_request,
            QueryListGroupsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_group_member(
        self,
        query_head_group_member_request: "QueryHeadGroupMemberRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadGroupMemberResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadGroupMember",
            query_head_group_member_request,
            QueryHeadGroupMemberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_policy_for_group(
        self,
        query_policy_for_group_request: "QueryPolicyForGroupRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPolicyForGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryPolicyForGroup",
            query_policy_for_group_request,
            QueryPolicyForGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_policy_by_id(
        self,
        query_policy_by_id_request: "QueryPolicyByIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryPolicyByIdResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryPolicyById",
            query_policy_by_id_request,
            QueryPolicyByIdResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_lock_fee(
        self,
        query_lock_fee_request: "QueryLockFeeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryLockFeeResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryLockFee",
            query_lock_fee_request,
            QueryLockFeeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def head_bucket_extra(
        self,
        query_head_bucket_extra_request: "QueryHeadBucketExtraRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryHeadBucketExtraResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/HeadBucketExtra",
            query_head_bucket_extra_request,
            QueryHeadBucketExtraResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_is_price_changed(
        self,
        query_is_price_changed_request: "QueryIsPriceChangedRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryIsPriceChangedResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryIsPriceChanged",
            query_is_price_changed_request,
            QueryIsPriceChangedResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_quota_update_time(
        self,
        query_quote_update_time_request: "QueryQuoteUpdateTimeRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryQuoteUpdateTimeResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryQuotaUpdateTime",
            query_quote_update_time_request,
            QueryQuoteUpdateTimeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_group_members_exist(
        self,
        query_group_members_exist_request: "QueryGroupMembersExistRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupMembersExistResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryGroupMembersExist",
            query_group_members_exist_request,
            QueryGroupMembersExistResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_groups_exist(
        self,
        query_groups_exist_request: "QueryGroupsExistRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsExistResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryGroupsExist",
            query_groups_exist_request,
            QueryGroupsExistResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def query_groups_exist_by_id(
        self,
        query_groups_exist_by_id_request: "QueryGroupsExistByIdRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "QueryGroupsExistResponse":
        return await self._unary_unary(
            "/greenfield.storage.Query/QueryGroupsExistById",
            query_groups_exist_by_id_request,
            QueryGroupsExistResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MsgStub(betterproto.ServiceStub):
    async def create_bucket(
        self,
        msg_create_bucket: "MsgCreateBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CreateBucket",
            msg_create_bucket,
            MsgCreateBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_bucket(
        self,
        msg_delete_bucket: "MsgDeleteBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDeleteBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DeleteBucket",
            msg_delete_bucket,
            MsgDeleteBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_bucket_info(
        self,
        msg_update_bucket_info: "MsgUpdateBucketInfo",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateBucketInfoResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/UpdateBucketInfo",
            msg_update_bucket_info,
            MsgUpdateBucketInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def mirror_bucket(
        self,
        msg_mirror_bucket: "MsgMirrorBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMirrorBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/MirrorBucket",
            msg_mirror_bucket,
            MsgMirrorBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def discontinue_bucket(
        self,
        msg_discontinue_bucket: "MsgDiscontinueBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDiscontinueBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DiscontinueBucket",
            msg_discontinue_bucket,
            MsgDiscontinueBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_object(
        self,
        msg_create_object: "MsgCreateObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CreateObject",
            msg_create_object,
            MsgCreateObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def seal_object(
        self,
        msg_seal_object: "MsgSealObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgSealObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/SealObject",
            msg_seal_object,
            MsgSealObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def reject_seal_object(
        self,
        msg_reject_seal_object: "MsgRejectSealObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgRejectSealObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/RejectSealObject",
            msg_reject_seal_object,
            MsgRejectSealObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def copy_object(
        self,
        msg_copy_object: "MsgCopyObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCopyObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CopyObject",
            msg_copy_object,
            MsgCopyObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_object(
        self,
        msg_delete_object: "MsgDeleteObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDeleteObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DeleteObject",
            msg_delete_object,
            MsgDeleteObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_create_object(
        self,
        msg_cancel_create_object: "MsgCancelCreateObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCancelCreateObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CancelCreateObject",
            msg_cancel_create_object,
            MsgCancelCreateObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def mirror_object(
        self,
        msg_mirror_object: "MsgMirrorObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMirrorObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/MirrorObject",
            msg_mirror_object,
            MsgMirrorObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def discontinue_object(
        self,
        msg_discontinue_object: "MsgDiscontinueObject",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDiscontinueObjectResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DiscontinueObject",
            msg_discontinue_object,
            MsgDiscontinueObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_object_info(
        self,
        msg_update_object_info: "MsgUpdateObjectInfo",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateObjectInfoResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/UpdateObjectInfo",
            msg_update_object_info,
            MsgUpdateObjectInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def create_group(
        self,
        msg_create_group: "MsgCreateGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCreateGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CreateGroup",
            msg_create_group,
            MsgCreateGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_group(
        self,
        msg_delete_group: "MsgDeleteGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDeleteGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DeleteGroup",
            msg_delete_group,
            MsgDeleteGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_member(
        self,
        msg_update_group_member: "MsgUpdateGroupMember",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupMemberResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/UpdateGroupMember",
            msg_update_group_member,
            MsgUpdateGroupMemberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_group_extra(
        self,
        msg_update_group_extra: "MsgUpdateGroupExtra",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateGroupExtraResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/UpdateGroupExtra",
            msg_update_group_extra,
            MsgUpdateGroupExtraResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def leave_group(
        self,
        msg_leave_group: "MsgLeaveGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgLeaveGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/LeaveGroup",
            msg_leave_group,
            MsgLeaveGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def mirror_group(
        self,
        msg_mirror_group: "MsgMirrorGroup",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMirrorGroupResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/MirrorGroup",
            msg_mirror_group,
            MsgMirrorGroupResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def renew_group_member(
        self,
        msg_renew_group_member: "MsgRenewGroupMember",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgRenewGroupMemberResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/RenewGroupMember",
            msg_renew_group_member,
            MsgRenewGroupMemberResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def put_policy(
        self,
        msg_put_policy: "MsgPutPolicy",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgPutPolicyResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/PutPolicy",
            msg_put_policy,
            MsgPutPolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def delete_policy(
        self,
        msg_delete_policy: "MsgDeletePolicy",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgDeletePolicyResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/DeletePolicy",
            msg_delete_policy,
            MsgDeletePolicyResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def update_params(
        self,
        msg_update_params: "MsgUpdateParams",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgUpdateParamsResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/UpdateParams",
            msg_update_params,
            MsgUpdateParamsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def migrate_bucket(
        self,
        msg_migrate_bucket: "MsgMigrateBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgMigrateBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/MigrateBucket",
            msg_migrate_bucket,
            MsgMigrateBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def complete_migrate_bucket(
        self,
        msg_complete_migrate_bucket: "MsgCompleteMigrateBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCompleteMigrateBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CompleteMigrateBucket",
            msg_complete_migrate_bucket,
            MsgCompleteMigrateBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def cancel_migrate_bucket(
        self,
        msg_cancel_migrate_bucket: "MsgCancelMigrateBucket",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "MsgCancelMigrateBucketResponse":
        return await self._unary_unary(
            "/greenfield.storage.Msg/CancelMigrateBucket",
            msg_cancel_migrate_bucket,
            MsgCancelMigrateBucketResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class QueryBase(ServiceBase):
    async def params(self, query_params_request: "QueryParamsRequest") -> "QueryParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_params_by_timestamp(
        self, query_params_by_timestamp_request: "QueryParamsByTimestampRequest"
    ) -> "QueryParamsByTimestampResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_bucket(self, query_head_bucket_request: "QueryHeadBucketRequest") -> "QueryHeadBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_bucket_by_id(
        self, query_head_bucket_by_id_request: "QueryHeadBucketByIdRequest"
    ) -> "QueryHeadBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_bucket_nft(self, query_nft_request: "QueryNftRequest") -> "QueryBucketNftResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_object(self, query_head_object_request: "QueryHeadObjectRequest") -> "QueryHeadObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_object_by_id(
        self, query_head_object_by_id_request: "QueryHeadObjectByIdRequest"
    ) -> "QueryHeadObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_object_nft(self, query_nft_request: "QueryNftRequest") -> "QueryObjectNftResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_buckets(self, query_list_buckets_request: "QueryListBucketsRequest") -> "QueryListBucketsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_objects(self, query_list_objects_request: "QueryListObjectsRequest") -> "QueryListObjectsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_objects_by_bucket_id(
        self,
        query_list_objects_by_bucket_id_request: "QueryListObjectsByBucketIdRequest",
    ) -> "QueryListObjectsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_group_nft(self, query_nft_request: "QueryNftRequest") -> "QueryGroupNftResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_policy_for_account(
        self, query_policy_for_account_request: "QueryPolicyForAccountRequest"
    ) -> "QueryPolicyForAccountResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def verify_permission(
        self, query_verify_permission_request: "QueryVerifyPermissionRequest"
    ) -> "QueryVerifyPermissionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_group(self, query_head_group_request: "QueryHeadGroupRequest") -> "QueryHeadGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_groups(self, query_list_groups_request: "QueryListGroupsRequest") -> "QueryListGroupsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_group_member(
        self, query_head_group_member_request: "QueryHeadGroupMemberRequest"
    ) -> "QueryHeadGroupMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_policy_for_group(
        self, query_policy_for_group_request: "QueryPolicyForGroupRequest"
    ) -> "QueryPolicyForGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_policy_by_id(
        self, query_policy_by_id_request: "QueryPolicyByIdRequest"
    ) -> "QueryPolicyByIdResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_lock_fee(self, query_lock_fee_request: "QueryLockFeeRequest") -> "QueryLockFeeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def head_bucket_extra(
        self, query_head_bucket_extra_request: "QueryHeadBucketExtraRequest"
    ) -> "QueryHeadBucketExtraResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_is_price_changed(
        self, query_is_price_changed_request: "QueryIsPriceChangedRequest"
    ) -> "QueryIsPriceChangedResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_quota_update_time(
        self, query_quote_update_time_request: "QueryQuoteUpdateTimeRequest"
    ) -> "QueryQuoteUpdateTimeResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_group_members_exist(
        self, query_group_members_exist_request: "QueryGroupMembersExistRequest"
    ) -> "QueryGroupMembersExistResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_groups_exist(
        self, query_groups_exist_request: "QueryGroupsExistRequest"
    ) -> "QueryGroupsExistResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_groups_exist_by_id(
        self, query_groups_exist_by_id_request: "QueryGroupsExistByIdRequest"
    ) -> "QueryGroupsExistResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_params(self, stream: "grpclib.server.Stream[QueryParamsRequest, QueryParamsResponse]") -> None:
        request = await stream.recv_message()
        response = await self.params(request)
        await stream.send_message(response)

    async def __rpc_query_params_by_timestamp(
        self,
        stream: "grpclib.server.Stream[QueryParamsByTimestampRequest, QueryParamsByTimestampResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_params_by_timestamp(request)
        await stream.send_message(response)

    async def __rpc_head_bucket(
        self,
        stream: "grpclib.server.Stream[QueryHeadBucketRequest, QueryHeadBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_bucket(request)
        await stream.send_message(response)

    async def __rpc_head_bucket_by_id(
        self,
        stream: "grpclib.server.Stream[QueryHeadBucketByIdRequest, QueryHeadBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_bucket_by_id(request)
        await stream.send_message(response)

    async def __rpc_head_bucket_nft(
        self, stream: "grpclib.server.Stream[QueryNftRequest, QueryBucketNftResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_bucket_nft(request)
        await stream.send_message(response)

    async def __rpc_head_object(
        self,
        stream: "grpclib.server.Stream[QueryHeadObjectRequest, QueryHeadObjectResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_object(request)
        await stream.send_message(response)

    async def __rpc_head_object_by_id(
        self,
        stream: "grpclib.server.Stream[QueryHeadObjectByIdRequest, QueryHeadObjectResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_object_by_id(request)
        await stream.send_message(response)

    async def __rpc_head_object_nft(
        self, stream: "grpclib.server.Stream[QueryNftRequest, QueryObjectNftResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_object_nft(request)
        await stream.send_message(response)

    async def __rpc_list_buckets(
        self,
        stream: "grpclib.server.Stream[QueryListBucketsRequest, QueryListBucketsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_buckets(request)
        await stream.send_message(response)

    async def __rpc_list_objects(
        self,
        stream: "grpclib.server.Stream[QueryListObjectsRequest, QueryListObjectsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_objects(request)
        await stream.send_message(response)

    async def __rpc_list_objects_by_bucket_id(
        self,
        stream: "grpclib.server.Stream[QueryListObjectsByBucketIdRequest, QueryListObjectsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_objects_by_bucket_id(request)
        await stream.send_message(response)

    async def __rpc_head_group_nft(
        self, stream: "grpclib.server.Stream[QueryNftRequest, QueryGroupNftResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_group_nft(request)
        await stream.send_message(response)

    async def __rpc_query_policy_for_account(
        self,
        stream: "grpclib.server.Stream[QueryPolicyForAccountRequest, QueryPolicyForAccountResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_policy_for_account(request)
        await stream.send_message(response)

    async def __rpc_verify_permission(
        self,
        stream: "grpclib.server.Stream[QueryVerifyPermissionRequest, QueryVerifyPermissionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.verify_permission(request)
        await stream.send_message(response)

    async def __rpc_head_group(
        self,
        stream: "grpclib.server.Stream[QueryHeadGroupRequest, QueryHeadGroupResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_group(request)
        await stream.send_message(response)

    async def __rpc_list_groups(
        self,
        stream: "grpclib.server.Stream[QueryListGroupsRequest, QueryListGroupsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_groups(request)
        await stream.send_message(response)

    async def __rpc_head_group_member(
        self,
        stream: "grpclib.server.Stream[QueryHeadGroupMemberRequest, QueryHeadGroupMemberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_group_member(request)
        await stream.send_message(response)

    async def __rpc_query_policy_for_group(
        self,
        stream: "grpclib.server.Stream[QueryPolicyForGroupRequest, QueryPolicyForGroupResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_policy_for_group(request)
        await stream.send_message(response)

    async def __rpc_query_policy_by_id(
        self,
        stream: "grpclib.server.Stream[QueryPolicyByIdRequest, QueryPolicyByIdResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_policy_by_id(request)
        await stream.send_message(response)

    async def __rpc_query_lock_fee(
        self, stream: "grpclib.server.Stream[QueryLockFeeRequest, QueryLockFeeResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_lock_fee(request)
        await stream.send_message(response)

    async def __rpc_head_bucket_extra(
        self,
        stream: "grpclib.server.Stream[QueryHeadBucketExtraRequest, QueryHeadBucketExtraResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.head_bucket_extra(request)
        await stream.send_message(response)

    async def __rpc_query_is_price_changed(
        self,
        stream: "grpclib.server.Stream[QueryIsPriceChangedRequest, QueryIsPriceChangedResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_is_price_changed(request)
        await stream.send_message(response)

    async def __rpc_query_quota_update_time(
        self,
        stream: "grpclib.server.Stream[QueryQuoteUpdateTimeRequest, QueryQuoteUpdateTimeResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_quota_update_time(request)
        await stream.send_message(response)

    async def __rpc_query_group_members_exist(
        self,
        stream: "grpclib.server.Stream[QueryGroupMembersExistRequest, QueryGroupMembersExistResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_group_members_exist(request)
        await stream.send_message(response)

    async def __rpc_query_groups_exist(
        self,
        stream: "grpclib.server.Stream[QueryGroupsExistRequest, QueryGroupsExistResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_groups_exist(request)
        await stream.send_message(response)

    async def __rpc_query_groups_exist_by_id(
        self,
        stream: "grpclib.server.Stream[QueryGroupsExistByIdRequest, QueryGroupsExistResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.query_groups_exist_by_id(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/greenfield.storage.Query/Params": grpclib.const.Handler(
                self.__rpc_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsRequest,
                QueryParamsResponse,
            ),
            "/greenfield.storage.Query/QueryParamsByTimestamp": grpclib.const.Handler(
                self.__rpc_query_params_by_timestamp,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryParamsByTimestampRequest,
                QueryParamsByTimestampResponse,
            ),
            "/greenfield.storage.Query/HeadBucket": grpclib.const.Handler(
                self.__rpc_head_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadBucketRequest,
                QueryHeadBucketResponse,
            ),
            "/greenfield.storage.Query/HeadBucketById": grpclib.const.Handler(
                self.__rpc_head_bucket_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadBucketByIdRequest,
                QueryHeadBucketResponse,
            ),
            "/greenfield.storage.Query/HeadBucketNFT": grpclib.const.Handler(
                self.__rpc_head_bucket_nft,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNftRequest,
                QueryBucketNftResponse,
            ),
            "/greenfield.storage.Query/HeadObject": grpclib.const.Handler(
                self.__rpc_head_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadObjectRequest,
                QueryHeadObjectResponse,
            ),
            "/greenfield.storage.Query/HeadObjectById": grpclib.const.Handler(
                self.__rpc_head_object_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadObjectByIdRequest,
                QueryHeadObjectResponse,
            ),
            "/greenfield.storage.Query/HeadObjectNFT": grpclib.const.Handler(
                self.__rpc_head_object_nft,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNftRequest,
                QueryObjectNftResponse,
            ),
            "/greenfield.storage.Query/ListBuckets": grpclib.const.Handler(
                self.__rpc_list_buckets,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryListBucketsRequest,
                QueryListBucketsResponse,
            ),
            "/greenfield.storage.Query/ListObjects": grpclib.const.Handler(
                self.__rpc_list_objects,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryListObjectsRequest,
                QueryListObjectsResponse,
            ),
            "/greenfield.storage.Query/ListObjectsByBucketId": grpclib.const.Handler(
                self.__rpc_list_objects_by_bucket_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryListObjectsByBucketIdRequest,
                QueryListObjectsResponse,
            ),
            "/greenfield.storage.Query/HeadGroupNFT": grpclib.const.Handler(
                self.__rpc_head_group_nft,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryNftRequest,
                QueryGroupNftResponse,
            ),
            "/greenfield.storage.Query/QueryPolicyForAccount": grpclib.const.Handler(
                self.__rpc_query_policy_for_account,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPolicyForAccountRequest,
                QueryPolicyForAccountResponse,
            ),
            "/greenfield.storage.Query/VerifyPermission": grpclib.const.Handler(
                self.__rpc_verify_permission,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryVerifyPermissionRequest,
                QueryVerifyPermissionResponse,
            ),
            "/greenfield.storage.Query/HeadGroup": grpclib.const.Handler(
                self.__rpc_head_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadGroupRequest,
                QueryHeadGroupResponse,
            ),
            "/greenfield.storage.Query/ListGroups": grpclib.const.Handler(
                self.__rpc_list_groups,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryListGroupsRequest,
                QueryListGroupsResponse,
            ),
            "/greenfield.storage.Query/HeadGroupMember": grpclib.const.Handler(
                self.__rpc_head_group_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadGroupMemberRequest,
                QueryHeadGroupMemberResponse,
            ),
            "/greenfield.storage.Query/QueryPolicyForGroup": grpclib.const.Handler(
                self.__rpc_query_policy_for_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPolicyForGroupRequest,
                QueryPolicyForGroupResponse,
            ),
            "/greenfield.storage.Query/QueryPolicyById": grpclib.const.Handler(
                self.__rpc_query_policy_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryPolicyByIdRequest,
                QueryPolicyByIdResponse,
            ),
            "/greenfield.storage.Query/QueryLockFee": grpclib.const.Handler(
                self.__rpc_query_lock_fee,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryLockFeeRequest,
                QueryLockFeeResponse,
            ),
            "/greenfield.storage.Query/HeadBucketExtra": grpclib.const.Handler(
                self.__rpc_head_bucket_extra,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryHeadBucketExtraRequest,
                QueryHeadBucketExtraResponse,
            ),
            "/greenfield.storage.Query/QueryIsPriceChanged": grpclib.const.Handler(
                self.__rpc_query_is_price_changed,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryIsPriceChangedRequest,
                QueryIsPriceChangedResponse,
            ),
            "/greenfield.storage.Query/QueryQuotaUpdateTime": grpclib.const.Handler(
                self.__rpc_query_quota_update_time,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryQuoteUpdateTimeRequest,
                QueryQuoteUpdateTimeResponse,
            ),
            "/greenfield.storage.Query/QueryGroupMembersExist": grpclib.const.Handler(
                self.__rpc_query_group_members_exist,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupMembersExistRequest,
                QueryGroupMembersExistResponse,
            ),
            "/greenfield.storage.Query/QueryGroupsExist": grpclib.const.Handler(
                self.__rpc_query_groups_exist,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsExistRequest,
                QueryGroupsExistResponse,
            ),
            "/greenfield.storage.Query/QueryGroupsExistById": grpclib.const.Handler(
                self.__rpc_query_groups_exist_by_id,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryGroupsExistByIdRequest,
                QueryGroupsExistResponse,
            ),
        }


class MsgBase(ServiceBase):
    async def create_bucket(self, msg_create_bucket: "MsgCreateBucket") -> "MsgCreateBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_bucket(self, msg_delete_bucket: "MsgDeleteBucket") -> "MsgDeleteBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_bucket_info(self, msg_update_bucket_info: "MsgUpdateBucketInfo") -> "MsgUpdateBucketInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def mirror_bucket(self, msg_mirror_bucket: "MsgMirrorBucket") -> "MsgMirrorBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def discontinue_bucket(
        self, msg_discontinue_bucket: "MsgDiscontinueBucket"
    ) -> "MsgDiscontinueBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_object(self, msg_create_object: "MsgCreateObject") -> "MsgCreateObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def seal_object(self, msg_seal_object: "MsgSealObject") -> "MsgSealObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def reject_seal_object(self, msg_reject_seal_object: "MsgRejectSealObject") -> "MsgRejectSealObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def copy_object(self, msg_copy_object: "MsgCopyObject") -> "MsgCopyObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_object(self, msg_delete_object: "MsgDeleteObject") -> "MsgDeleteObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_create_object(
        self, msg_cancel_create_object: "MsgCancelCreateObject"
    ) -> "MsgCancelCreateObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def mirror_object(self, msg_mirror_object: "MsgMirrorObject") -> "MsgMirrorObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def discontinue_object(
        self, msg_discontinue_object: "MsgDiscontinueObject"
    ) -> "MsgDiscontinueObjectResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_object_info(self, msg_update_object_info: "MsgUpdateObjectInfo") -> "MsgUpdateObjectInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def create_group(self, msg_create_group: "MsgCreateGroup") -> "MsgCreateGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_group(self, msg_delete_group: "MsgDeleteGroup") -> "MsgDeleteGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_member(
        self, msg_update_group_member: "MsgUpdateGroupMember"
    ) -> "MsgUpdateGroupMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_group_extra(self, msg_update_group_extra: "MsgUpdateGroupExtra") -> "MsgUpdateGroupExtraResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def leave_group(self, msg_leave_group: "MsgLeaveGroup") -> "MsgLeaveGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def mirror_group(self, msg_mirror_group: "MsgMirrorGroup") -> "MsgMirrorGroupResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def renew_group_member(self, msg_renew_group_member: "MsgRenewGroupMember") -> "MsgRenewGroupMemberResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def put_policy(self, msg_put_policy: "MsgPutPolicy") -> "MsgPutPolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_policy(self, msg_delete_policy: "MsgDeletePolicy") -> "MsgDeletePolicyResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_params(self, msg_update_params: "MsgUpdateParams") -> "MsgUpdateParamsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def migrate_bucket(self, msg_migrate_bucket: "MsgMigrateBucket") -> "MsgMigrateBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def complete_migrate_bucket(
        self, msg_complete_migrate_bucket: "MsgCompleteMigrateBucket"
    ) -> "MsgCompleteMigrateBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def cancel_migrate_bucket(
        self, msg_cancel_migrate_bucket: "MsgCancelMigrateBucket"
    ) -> "MsgCancelMigrateBucketResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_create_bucket(
        self, stream: "grpclib.server.Stream[MsgCreateBucket, MsgCreateBucketResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_bucket(request)
        await stream.send_message(response)

    async def __rpc_delete_bucket(
        self, stream: "grpclib.server.Stream[MsgDeleteBucket, MsgDeleteBucketResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_bucket(request)
        await stream.send_message(response)

    async def __rpc_update_bucket_info(
        self,
        stream: "grpclib.server.Stream[MsgUpdateBucketInfo, MsgUpdateBucketInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_bucket_info(request)
        await stream.send_message(response)

    async def __rpc_mirror_bucket(
        self, stream: "grpclib.server.Stream[MsgMirrorBucket, MsgMirrorBucketResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.mirror_bucket(request)
        await stream.send_message(response)

    async def __rpc_discontinue_bucket(
        self,
        stream: "grpclib.server.Stream[MsgDiscontinueBucket, MsgDiscontinueBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.discontinue_bucket(request)
        await stream.send_message(response)

    async def __rpc_create_object(
        self, stream: "grpclib.server.Stream[MsgCreateObject, MsgCreateObjectResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.create_object(request)
        await stream.send_message(response)

    async def __rpc_seal_object(self, stream: "grpclib.server.Stream[MsgSealObject, MsgSealObjectResponse]") -> None:
        request = await stream.recv_message()
        response = await self.seal_object(request)
        await stream.send_message(response)

    async def __rpc_reject_seal_object(
        self,
        stream: "grpclib.server.Stream[MsgRejectSealObject, MsgRejectSealObjectResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.reject_seal_object(request)
        await stream.send_message(response)

    async def __rpc_copy_object(self, stream: "grpclib.server.Stream[MsgCopyObject, MsgCopyObjectResponse]") -> None:
        request = await stream.recv_message()
        response = await self.copy_object(request)
        await stream.send_message(response)

    async def __rpc_delete_object(
        self, stream: "grpclib.server.Stream[MsgDeleteObject, MsgDeleteObjectResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_object(request)
        await stream.send_message(response)

    async def __rpc_cancel_create_object(
        self,
        stream: "grpclib.server.Stream[MsgCancelCreateObject, MsgCancelCreateObjectResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_create_object(request)
        await stream.send_message(response)

    async def __rpc_mirror_object(
        self, stream: "grpclib.server.Stream[MsgMirrorObject, MsgMirrorObjectResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.mirror_object(request)
        await stream.send_message(response)

    async def __rpc_discontinue_object(
        self,
        stream: "grpclib.server.Stream[MsgDiscontinueObject, MsgDiscontinueObjectResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.discontinue_object(request)
        await stream.send_message(response)

    async def __rpc_update_object_info(
        self,
        stream: "grpclib.server.Stream[MsgUpdateObjectInfo, MsgUpdateObjectInfoResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_object_info(request)
        await stream.send_message(response)

    async def __rpc_create_group(self, stream: "grpclib.server.Stream[MsgCreateGroup, MsgCreateGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.create_group(request)
        await stream.send_message(response)

    async def __rpc_delete_group(self, stream: "grpclib.server.Stream[MsgDeleteGroup, MsgDeleteGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.delete_group(request)
        await stream.send_message(response)

    async def __rpc_update_group_member(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupMember, MsgUpdateGroupMemberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_member(request)
        await stream.send_message(response)

    async def __rpc_update_group_extra(
        self,
        stream: "grpclib.server.Stream[MsgUpdateGroupExtra, MsgUpdateGroupExtraResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_group_extra(request)
        await stream.send_message(response)

    async def __rpc_leave_group(self, stream: "grpclib.server.Stream[MsgLeaveGroup, MsgLeaveGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.leave_group(request)
        await stream.send_message(response)

    async def __rpc_mirror_group(self, stream: "grpclib.server.Stream[MsgMirrorGroup, MsgMirrorGroupResponse]") -> None:
        request = await stream.recv_message()
        response = await self.mirror_group(request)
        await stream.send_message(response)

    async def __rpc_renew_group_member(
        self,
        stream: "grpclib.server.Stream[MsgRenewGroupMember, MsgRenewGroupMemberResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.renew_group_member(request)
        await stream.send_message(response)

    async def __rpc_put_policy(self, stream: "grpclib.server.Stream[MsgPutPolicy, MsgPutPolicyResponse]") -> None:
        request = await stream.recv_message()
        response = await self.put_policy(request)
        await stream.send_message(response)

    async def __rpc_delete_policy(
        self, stream: "grpclib.server.Stream[MsgDeletePolicy, MsgDeletePolicyResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.delete_policy(request)
        await stream.send_message(response)

    async def __rpc_update_params(
        self, stream: "grpclib.server.Stream[MsgUpdateParams, MsgUpdateParamsResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.update_params(request)
        await stream.send_message(response)

    async def __rpc_migrate_bucket(
        self,
        stream: "grpclib.server.Stream[MsgMigrateBucket, MsgMigrateBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.migrate_bucket(request)
        await stream.send_message(response)

    async def __rpc_complete_migrate_bucket(
        self,
        stream: "grpclib.server.Stream[MsgCompleteMigrateBucket, MsgCompleteMigrateBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.complete_migrate_bucket(request)
        await stream.send_message(response)

    async def __rpc_cancel_migrate_bucket(
        self,
        stream: "grpclib.server.Stream[MsgCancelMigrateBucket, MsgCancelMigrateBucketResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.cancel_migrate_bucket(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/greenfield.storage.Msg/CreateBucket": grpclib.const.Handler(
                self.__rpc_create_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateBucket,
                MsgCreateBucketResponse,
            ),
            "/greenfield.storage.Msg/DeleteBucket": grpclib.const.Handler(
                self.__rpc_delete_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeleteBucket,
                MsgDeleteBucketResponse,
            ),
            "/greenfield.storage.Msg/UpdateBucketInfo": grpclib.const.Handler(
                self.__rpc_update_bucket_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateBucketInfo,
                MsgUpdateBucketInfoResponse,
            ),
            "/greenfield.storage.Msg/MirrorBucket": grpclib.const.Handler(
                self.__rpc_mirror_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMirrorBucket,
                MsgMirrorBucketResponse,
            ),
            "/greenfield.storage.Msg/DiscontinueBucket": grpclib.const.Handler(
                self.__rpc_discontinue_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDiscontinueBucket,
                MsgDiscontinueBucketResponse,
            ),
            "/greenfield.storage.Msg/CreateObject": grpclib.const.Handler(
                self.__rpc_create_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateObject,
                MsgCreateObjectResponse,
            ),
            "/greenfield.storage.Msg/SealObject": grpclib.const.Handler(
                self.__rpc_seal_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgSealObject,
                MsgSealObjectResponse,
            ),
            "/greenfield.storage.Msg/RejectSealObject": grpclib.const.Handler(
                self.__rpc_reject_seal_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRejectSealObject,
                MsgRejectSealObjectResponse,
            ),
            "/greenfield.storage.Msg/CopyObject": grpclib.const.Handler(
                self.__rpc_copy_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCopyObject,
                MsgCopyObjectResponse,
            ),
            "/greenfield.storage.Msg/DeleteObject": grpclib.const.Handler(
                self.__rpc_delete_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeleteObject,
                MsgDeleteObjectResponse,
            ),
            "/greenfield.storage.Msg/CancelCreateObject": grpclib.const.Handler(
                self.__rpc_cancel_create_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCancelCreateObject,
                MsgCancelCreateObjectResponse,
            ),
            "/greenfield.storage.Msg/MirrorObject": grpclib.const.Handler(
                self.__rpc_mirror_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMirrorObject,
                MsgMirrorObjectResponse,
            ),
            "/greenfield.storage.Msg/DiscontinueObject": grpclib.const.Handler(
                self.__rpc_discontinue_object,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDiscontinueObject,
                MsgDiscontinueObjectResponse,
            ),
            "/greenfield.storage.Msg/UpdateObjectInfo": grpclib.const.Handler(
                self.__rpc_update_object_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateObjectInfo,
                MsgUpdateObjectInfoResponse,
            ),
            "/greenfield.storage.Msg/CreateGroup": grpclib.const.Handler(
                self.__rpc_create_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCreateGroup,
                MsgCreateGroupResponse,
            ),
            "/greenfield.storage.Msg/DeleteGroup": grpclib.const.Handler(
                self.__rpc_delete_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeleteGroup,
                MsgDeleteGroupResponse,
            ),
            "/greenfield.storage.Msg/UpdateGroupMember": grpclib.const.Handler(
                self.__rpc_update_group_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupMember,
                MsgUpdateGroupMemberResponse,
            ),
            "/greenfield.storage.Msg/UpdateGroupExtra": grpclib.const.Handler(
                self.__rpc_update_group_extra,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateGroupExtra,
                MsgUpdateGroupExtraResponse,
            ),
            "/greenfield.storage.Msg/LeaveGroup": grpclib.const.Handler(
                self.__rpc_leave_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgLeaveGroup,
                MsgLeaveGroupResponse,
            ),
            "/greenfield.storage.Msg/MirrorGroup": grpclib.const.Handler(
                self.__rpc_mirror_group,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMirrorGroup,
                MsgMirrorGroupResponse,
            ),
            "/greenfield.storage.Msg/RenewGroupMember": grpclib.const.Handler(
                self.__rpc_renew_group_member,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgRenewGroupMember,
                MsgRenewGroupMemberResponse,
            ),
            "/greenfield.storage.Msg/PutPolicy": grpclib.const.Handler(
                self.__rpc_put_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgPutPolicy,
                MsgPutPolicyResponse,
            ),
            "/greenfield.storage.Msg/DeletePolicy": grpclib.const.Handler(
                self.__rpc_delete_policy,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgDeletePolicy,
                MsgDeletePolicyResponse,
            ),
            "/greenfield.storage.Msg/UpdateParams": grpclib.const.Handler(
                self.__rpc_update_params,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgUpdateParams,
                MsgUpdateParamsResponse,
            ),
            "/greenfield.storage.Msg/MigrateBucket": grpclib.const.Handler(
                self.__rpc_migrate_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgMigrateBucket,
                MsgMigrateBucketResponse,
            ),
            "/greenfield.storage.Msg/CompleteMigrateBucket": grpclib.const.Handler(
                self.__rpc_complete_migrate_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCompleteMigrateBucket,
                MsgCompleteMigrateBucketResponse,
            ),
            "/greenfield.storage.Msg/CancelMigrateBucket": grpclib.const.Handler(
                self.__rpc_cancel_migrate_bucket,
                grpclib.const.Cardinality.UNARY_UNARY,
                MsgCancelMigrateBucket,
                MsgCancelMigrateBucketResponse,
            ),
        }


BucketInfo.__pydantic_model__.update_forward_refs()  # type: ignore
InternalBucketInfo.__pydantic_model__.update_forward_refs()  # type: ignore
ObjectInfo.__pydantic_model__.update_forward_refs()  # type: ignore
GroupInfo.__pydantic_model__.update_forward_refs()  # type: ignore
BucketMetaData.__pydantic_model__.update_forward_refs()  # type: ignore
ObjectMetaData.__pydantic_model__.update_forward_refs()  # type: ignore
GroupMetaData.__pydantic_model__.update_forward_refs()  # type: ignore
DeleteInfo.__pydantic_model__.update_forward_refs()  # type: ignore
EventCreateBucket.__pydantic_model__.update_forward_refs()  # type: ignore
EventUpdateBucketInfo.__pydantic_model__.update_forward_refs()  # type: ignore
EventCreateObject.__pydantic_model__.update_forward_refs()  # type: ignore
EventSealObject.__pydantic_model__.update_forward_refs()  # type: ignore
EventUpdateObjectInfo.__pydantic_model__.update_forward_refs()  # type: ignore
EventCreateGroup.__pydantic_model__.update_forward_refs()  # type: ignore
EventUpdateGroupMember.__pydantic_model__.update_forward_refs()  # type: ignore
EventRenewGroupMember.__pydantic_model__.update_forward_refs()  # type: ignore
EventGroupMemberDetail.__pydantic_model__.update_forward_refs()  # type: ignore
EventStalePolicyCleanup.__pydantic_model__.update_forward_refs()  # type: ignore
Params.__pydantic_model__.update_forward_refs()  # type: ignore
GenesisState.__pydantic_model__.update_forward_refs()  # type: ignore
QueryParamsResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryParamsByTimestampResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryHeadBucketResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryHeadObjectResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListBucketsRequest.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListBucketsResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListObjectsRequest.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListObjectsByBucketIdRequest.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListObjectsResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryBucketNftResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryObjectNftResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryGroupNftResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryPolicyForAccountResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryVerifyPermissionRequest.__pydantic_model__.update_forward_refs()  # type: ignore
QueryVerifyPermissionResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryHeadGroupResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListGroupsRequest.__pydantic_model__.update_forward_refs()  # type: ignore
QueryListGroupsResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryHeadGroupMemberResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryPolicyForGroupResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryPolicyByIdResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryHeadBucketExtraResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryGroupMembersExistResponse.__pydantic_model__.update_forward_refs()  # type: ignore
QueryGroupsExistResponse.__pydantic_model__.update_forward_refs()  # type: ignore
MsgCreateBucket.__pydantic_model__.update_forward_refs()  # type: ignore
MsgCreateObject.__pydantic_model__.update_forward_refs()  # type: ignore
MsgCopyObject.__pydantic_model__.update_forward_refs()  # type: ignore
MsgUpdateGroupMember.__pydantic_model__.update_forward_refs()  # type: ignore
MsgRenewGroupMember.__pydantic_model__.update_forward_refs()  # type: ignore
MsgGroupMember.__pydantic_model__.update_forward_refs()  # type: ignore
MsgUpdateBucketInfo.__pydantic_model__.update_forward_refs()  # type: ignore
MsgPutPolicy.__pydantic_model__.update_forward_refs()  # type: ignore
MsgDeletePolicy.__pydantic_model__.update_forward_refs()  # type: ignore
MsgUpdateObjectInfo.__pydantic_model__.update_forward_refs()  # type: ignore
MsgUpdateParams.__pydantic_model__.update_forward_refs()  # type: ignore
MsgMigrateBucket.__pydantic_model__.update_forward_refs()  # type: ignore
MsgCompleteMigrateBucket.__pydantic_model__.update_forward_refs()  # type: ignore
